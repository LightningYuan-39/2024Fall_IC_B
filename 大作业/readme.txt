encoding:UTF-8

本文件夹属于项目1，其中包括服务器端server.py;客户端terminal.py;判定算法algorithm.py;游戏主程序simplified.py

一、对游戏规则的补充说明：
如果有不少于2个人在结束阶段选择和牌，则让本结束阶段对应的回合阶段对应的id逆时针方向第一个选择和牌的人和牌
二、服务端server.py和客户端terminal.py基本介绍
一局游戏开始之前，首先服务器开启，为了使多个用户得到正确端口号，服务器创建一个引导socket，用于发送目前还空闲的服务器端口号。
每一个客户端开启时首先与引导socket连接，获悉空闲端口号后与对应端口的socket连接。连接上后，client_sockets会保留这个socket。
首先服务端使用4个socket等待接客；之后start函数等待服务端接收第一个连接60s，若连接失败则退出程序；若接收成功，则继续等待服务端接受其他连接，
30s后会将未接到客户端的所有服务器socket销毁，并对所有已接到客户端的所有客户端socket执行simplified(游戏主体模块)的main函数。
游戏结束时，服务器会向所有真人客户端发送"Hu"或者'No winner'消息，客户端在10s内断开连接，服务端在退出main函数后，也在10s后断开连接，游戏结束。
三、simplified和algorithm程序架构
游戏的主要部分在main函数里执行。
（一）初始化
开始时初始化卡牌。
接下来，为了批量存放玩家的手牌、副露和牌河，代码第17行定义了一个类Player,并在__init__方法中传入hand,subhand,discards属性，以避免不同玩家的信息发生干扰
接下来，使用createrole函数根据socket数目创建4个玩家对象，分别编号为0,1,2,3，为了之后方便批量调用这些对象的方法，将这些玩家对象封装在列表playerlst中。
通过identity属性存放玩家到底是真人还是电脑，通过conn存放联系方式以便未来输入输出。
游戏开始时，先使用fenpai函数进行分牌，并按大小顺序整理。
分牌过后，所有真人客户端显示游戏提示信息，游戏的主要部分执行。
（二）主要部分
首先定义状态，"turn"和"end"分别表示回合阶段和结束阶段，定义一个参数叫turnnum,表示哪个id进行操作
如果牌堆已空，跳出循环，返回"no winner"信息；否则进行循环。
状态为turn时，需要更新以下三个参数：
1.turnnum,表示回合阶段属于哪个id；2.round_draw,表示从回合进行的规则来看，这一回合是否能够摸牌；3.round_hu,表示从回合进行的规则来看，这一回合是否能够和牌。
游戏开始时，这三个参数被设置为0,True,True
在执行回合阶段时，把这三个参数传递给player_turn函数，playerturn函数会返回玩家在此时操作的报告（例："Player0 Cut S1"）接下来根据报告进行状态转移。
状态转移方式：如果某玩家和牌，显示和牌信息，退出游戏；如果切牌或补杠，则进入结束阶段；如果暗杠，则回到回合阶段，id不变。
状态为end时，需要更新三个参数：
1.tagid,指对应回合阶段的id；2.tagcard,表明回合阶段操作的牌；3.is_gang2，指上一回合的操作是否为补杠，这三个参数可以通过解析回合报告得出
通过调用三次player_end函数，返回其余三个玩家选择的指令报告，之后根据优先级判定得到系统需要执行的报告，并在之后进行对应的牌操作，
最终返回确定回合阶段的三个参数。
在任何提示"Press any key to continue..."的时候，用户都可以输入Query,调用query函数进入查询模式，对于此函数后文不做介绍
（三）各个分函数介绍
游戏逻辑部分
1.player_turn函数
player_turn函数参数已在前文说明，用于控制回合阶段。首先，如果该回合能够摸牌则摸牌；之后，判断用户的牌型能否进行和牌、暗杠、补杠
(判断函数分别是card_hu,can_gang0,can_gang2(在algorithm.py中),后面两个函数之后不做介绍)其中只要暗杠或补杠的判断函数返回True即可暗杠或补杠，和牌的条件除了牌型要求之外，
还需要该局能够和牌。之后把动作打包成列表，如果id显示玩家为人，则终端弹出选择动作指令，如果用户输入错误则提示并重新读取用户输入，直至得到符合要求的报告；
如果id对应玩家为电脑，则电脑随机选择动作指令并返回符合要求的报告。用户如果输入切牌、暗杠和补杠，则在本函数里进行牌操作。
注意：在判断时程序采用将用户的手牌和副露进行深拷贝，以避免在可变对象中的用户信息被破坏
2.player_end函数
player_end函数有以下四个参数：
1.id,指进行结束阶段的玩家id；2.tagid,只对应回合阶段的玩家id；3.tagcard,指对应回合阶段打出的牌；4.is_gang2,指对应回合阶段是否为补杠,
其中第一个参数取遍所有不是tagid的值，第2-4个参数全部由main函数end状态读取并传入
player_end函数用于控制结束阶段。如果该阶段对应的回合阶段没有补杠，牌型允许碰、明杠，则加上碰、明杠两个操作，如果牌型能够吃并且是回合阶段的下家，则加上吃的操作；
另外，如果牌型能够和牌，则加上该操作。之后若执行结束阶段的为人类，则终端提示输入指令；若为电脑，则随机选择输入指令；
(在该函数里面没有进行牌操作，因为3个玩家的牌操作只允许1个)
3.card_hu
判断用户的牌型能否和牌。传入参数是某玩家的手牌列表。可以证明，只要手牌里存在一对将牌，其余均为刻子和顺子，手牌和副露加起来的面子数一定为4，故只需传入手牌参数
首先对手牌按花色进行分组，保证其中两个花色有3k（k为自然数）张牌，另外一个花色有（3k+2）张牌；否则返回False
之后对3k+2张牌的花色，遍历所有重复的牌，去掉两张相同的牌（使用multi_remove方法(ln54-57，之后不予介绍)返回多次去掉相同元素的列表），需要存在去掉之后的牌组，使得其为空或者由刻子和顺子组成，
对3k张牌的两种花色，也需要为空或者由刻子和顺子组成。所以定义了一个tri_hu函数）(ln58-70)
4.tri_hu
判断牌型是否为空或者全为面子
如果点数最小的牌数目不少于3，则将其视为一组刻子并去掉(如果不能用刻子表示，必然存在3个相同的顺子，而这个系统是可以用刻子来表示的，矛盾)
少于3则找到从其开头的一组顺子，并将其去掉
全过程若存在列表元素不存在，返回False
输入输出部分
1.prtinfo(id,sockseq,sock),传入的id是当前回合阶段的id，sockseq是发送的用户id，sock是发送的用户对应的socket
2.remote_print(sock,msg),sock指对应的用户socket,msg指发送的消息
3.remote_input(sock,hint),sock指对应的用户socket,hint指对应要求输入的提示信息
四、AI和他人代码使用情况：
以下是使用过AI和他人代码的所有部分：
1.在simplified函数中，由于定义类时把属性hand（手牌）设置为类的公共属性，借助文心一言debug,将其改为每一个实例化对象的属性（当时没有学到面向对象）；
2.关于asyncio的用法，有参考CSDN中的简单示例，并且在asyncio里面无法单独使用socket.accept方法，
借助北大问学的代码debug功能将其改成了asyncio.get_event_loop().sock_accept(server_socket)模式。
3.写客户端代码时，关于如何使客户端不停接受服务端指令，参考文心一言使用了setblocking和blockingIOerror方法。
其余没有借助任何ai及他人代码。
#受条件和时间限制，无法将完整的功能用视频加以展示，实表抱歉，更多功能，可以通过代码略知一二。